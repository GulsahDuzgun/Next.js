## What did I learn while coding this project?

> #
>
> - _**What is Client-Side Rendering?** In Client-Side rendering html is rendered on the client(the user's computer) using Javascript. It leads to slow initial page loads because the javascript bundle needs to be downloaded before anything else can happen on the page. Also most app require some data which can only start to be fetched after the components have already mounted. After they have been rendered on the client, so there is so-called request waterfall going on which will typically slow down the entire experience which is one of the main criticism of the client side rendering and single page applications. However it has highly interactive user experience. That because after the initial page load has been finished, the entire app has already been downloaded -except maybe for some new data-. SEO(Search Engine Optimization) can be problematic. The content is not rendered untill after the Javascript is executed and data is fetched. Therefore search enginees might find a blank page when they try to index the site. Client Side rendering sould be chosen for Single Page Application and don't need SEO (like tool internally used within a company - not accessible for everyone ),_
>
> - _**What is Server-Side Rendering?** In server-side rendering the html is generated on the server. The server sends the already generated website to the client whenever it's requested. It has faster initial page loads to be downloaded because a lot less javascript needs to be downloaded and executed because the client does not need any Javascript in order to render the html. It has already been rendered on the server. And second reason is data necessary for each page will be downloaded on the server right before the HTML is even generated. Data is fetched before HTML is rendered. The Data will be sent to the browser. As a result of this server-rendered websites tent to be less interactive because navigating from page to page may require the server to render a new page each time which is lead to full page reloads in the browser. However mordern frameworks such as Next.js allows developer to build server-side rendered pages that can hydrate on the client in order to become interactive later. Pre-generated content much easier for search engines to index. If the SEO is important then server side rendering should be chosen. That's the case, in all websites or applications that are mostly content-driven like e-commerce platforms, blogs, news sites or marketing websites where server side rendering is definitely a great choice. SEO has crucial role in getting users onto the site. ,_
> - _There are two type of server-side rendering: Static and Dynamic. In static rendering also known as Static Site Generation the HTML is generated at build time. Developer is finished developing the site they export it into static HTML,CSS and Javascript files which can be deployed onto a web server. This web server than not regenerate the markup all time. It will be send what was generated once by the developer in the begining. On the other hand we have dynamic rendering where the server does actually generate new HTML each time a new request hits the server. It will generate new pages for each user which is great when the underlying data changes often. ,_
> - _**The initial render of Serve-Side Rendering & Client-Side Rendering**: In Client-Side rendering once the user requests a page, all the server has to offer is essentially just an empty page. That page might have some CSS attached to it ans JS bundle as well which can be quite heavy because it will contain the entire app logic. After JS bundle has been downloaded and executed the app notices that it needs to fetch some data. We just render the Spinner and the user waits for the data to be fetched from the server(from an API endpoint). When the data arrive, at that point the application will re-render ÅŸtself with that new data. And initial page load. The Largest Contentful Paint(LCP) is time to show all the relevant content to the user. There is also First Paint Metric (FCP) which means that just something has been painted onto the screen. Content Paint much important than (FCP). In Server-Side Rendering When request comes in server start fetching all the relevant data for page, then the server takes the data and generates the page and sends the whole finished product to client. When the page reaches the client it already has all the content the user is interested in. Therefor this is where the content paint happens in this case. The Server-Side rendering the page initial page load is musch faster. ,The server initiates the data fetching, before the page or app is even renderd. Render is happened in Server Side. Because all of this Largest Contentful Paint happens much earlier than in client side rendering. So that if there is a content heavy sites, should use Server-Side Rendering. Where the users don't want to wait for all the content to appear. For interactivity in server-side rendering a process called hydration happens. Hydration is where static HTML becomes interactive by adding Javascript to it. ,_
> - _**What is Hydration?** When we render html in server-side,this html is sent to the client and rendered in the browser as a webpage.(LCP- The relevant data has been painted on the screen). The website which resulted from our initial React app is not interactive because it is just html. At that point hydration is a process that adds back the interactivity and the event handler that the initial React app had but that were lost in the process of server side rendering it. Rendering HTML on the server-side will remove all the interactivity from React app and will generate only the markup itself. That's why we need hydration to give back that interactivity to our rendered HTML webpage. HTML page that we got on the client will also download the React bundle of our initial React app. This bundle will hydrate the rendered static DOM of our web page. React will build back the component tree on the client and will compare it to the actual server-side rendered DOM that is currently on the page. If they produce same exact DOM, they will match and React will simply adopt the existing DOM and attach all event handlers and fire off existing effects. Instead of creating brand new DOm elements which can take a long time in hydration React simply attempts to adopt the already existing DOM. Hydration simply continues and finishes the process of server-side rendering. In the end we have exact same React app that we started with but on the client. After all process has finished, the page becomes interactive. This process only works the existing server rendered DOM fits exactly the React would output on the client. That because hydration can take a few seconds. If there were differences between the two DOMs then the page content would change after hydration finishes which would be pretty bad user experience. Therefore, if there is a mismatch between the page that we have and the page client-side React thinks we should have we get something called an hydration error. ,_
> - _Hydration Errord are not very common and we usually do not need to worry about hydration problems. Most common cases for hydration errors include incorrect nesting of HTML elements, rendering different data on the server and on the client, using APIs or variables that exist only in the browser (like window or local storage), incorrect use of side effects. ,_
> - _**What is Next.js?** Next.js is the react framework for the web, meta framework built on top of React. We can still use components, props, react hooks, etc. Set of convention and best practices regarding routing, data fetchin, etc. Next.js allows us to build complex, full-stack web applications and websites with React. Complete with data fetchin and data mutations on the server. Next.js implements all the cutting edge React features like React Server Components, Server Actions, Suspense ,_
> - _The Next.js key ingredients:_ > _1- Server-Side rendering(Dynamic and Static): Dynamic and Static can be selected for each route._ > _2- File-Based Routing Conventions: Next.js comes with two routers. That routes are defined entirely based on file system based conventions.There are also special file conventions for pages, layouts, errors, loading screens and so on._ > _3- Data Fetching and mutation on the server by using those React Server Components and Server Actions._ > _4- Optimizations :Next.js provides us optimizations techniques for our apps and especially for websites like images, fonts, SEO and preloading._
> - _There are two routers in Next.js. Those are App Router and Pages Router. App Router became stable in 2023 in v13.4. This is recommended way of starting new projects. App Router is the router was implemented full-stack architecture vision( like server components, actions, streaming, suspense, etc.). All this only available only App Router not in Pages Router. Pages Router is the legacy router. That we've been using since v1 of Next.js. For fetching data in Pages Router we need to use Next.js specific APIs such as getStaticProps and getServerSide Props. That APIs work at page level not at individual component level. App router uses fetch function to fetch data, and has more advanced routing like parallel routing But caching is very aggressive and confusing at App router. ,_
>
> #
