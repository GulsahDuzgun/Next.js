#### What did I learn while coding this project?

> #
>
> - _Client-Side React Apps are re-rendered when the state or parent's state is updated. Client-Side apps are interactive, have components but require a lot of JS to download and client-server data waterfalls. Server-Side Apps have no component or interactivity but also no need to build API. You can fetch all data easy and fast. It closes the data source and displaying all data with no javacsript was needed at all that means faster page load for our users. UI is function of state in Client-Side, function of data in Server-Side. So to provide interactive, has components and easy to fetch, close to the data source and no needs javascript dowloaded the React Server Components were introduced. ,_
> - _**What are React Server Componnets?** React Server Components(RSC) is a completely new full-stack architecture for building React apps. It introduces the server as an integral part of React compoonent trees. React tree extends to the server like a bridge that closes the gap between client and server. And the way in which React does that is by introducing a new kind of component which are server components. React Server Components(RSC) paradigm introdus us the server components that are only rendered on the server, never on the client. They are usually responsible for fetching data right on the server. The server components are only run on the server they have no interactivity, so no state which means that they require exactyly zero Javascript file in the downloadable bundle to do their job. With Server components we can build our application's back-end ,_
> - _Client components are our regular components they responsible for the interactivity. They are responsible for the interactivity, so where the app still function of state. ,_
> - _React Server Components are not active in react app because it needs server to render html before._
> - _In RSC paradigm Server Components are default components. For using Client Components we need to specift the "use client" directive at the top of the module. And Client Components childrens also have to be Client Component. There is no need to specify the "use client" for childrens of Client Components. ,_
> - _The uninteractive part of app doesn't sent any javascript file to the the browser. They are rendered in server. If the component is interactive, the user can effect by clicking, etc. then Client-Component should be used to keep state. ,_
>
> - _Server-client boundary as an split points that are runs on the server and code that runs on the client. We use "use client" in order to create these server-client boundaries which in turn will create client sub-trees. Sub-trees that will be executed in the browser. ,_
> - _Server Components are the default components in the RSC model. Server Components can not be stateful and can't use any hooks. ,_
> - _Client Components are not the default component so they have to be clerified wit "use client" at the top of the module. Client Components are interactive so they can have state or hooks. Client Components can lift state up but server components don't because they haven't state. ,_
> - _Client Components and Server Components can have props but in Server Component they have to be serializable when passed to Client Components. Functions and Classes not serializable. _
> - _ First class way fetching data in React is asycn/await calls in top level code of a Server Component. Also we can fetch data in Client Components. ,_
> - _Server components can import both client and server component but Client Component just can import client component. Client Components can not go back client components. ,_
> - _Client components and server components passed as props and can be render. ,_
> - _On Client Component whenever its state or its parents state changes it will be re-rendered. Whenever the url changes then Server component will be re-render. Because server components are tied to specific routes in the framework.,_
> - _**What are the Good Part of React Server Components?** We can encapsulate all server side concernd right into components as well. We can compose entire full-stack applications by only writing components. And it feels we have one single codebase for front-end and back-end. Server Components are already in the back-end so they have a direct access to the data source. Server components can eliminate all kinds of client-server waterfalls. Instead of fetching one piece of data after another in different client components in the browser, we can just fetch all the data that we need on the server at once and send our stream the final result to the browser all in one go. Server components do not require ant javascript to the browser because that's not where they are executed. We can call this as "Disappearing code" because this fact allows us to import and use huge libraries in the server components without increasing the bundle size at all for free. ,_
> - _**What are the Bad Part of React Server Components?** Things like Context API don't work in server components like all other hooks. We need to make decisions all the time "Should I fetch this data on the server or the client?". If we need mobile app, we have to build an API. Server Components only works with frameworks. ,_
> - _How rendering works in traditional React? The Components that we wrote. Then we compose these component's intances and create tree od component instances which simply calls component tree in React. Rendering means in React call each component function. The result of the calling a component function(return) is a React element which is a Javascript object contains all the necessary information to create DOM elements for the corresponding component instance. As a result of rendering we end up with React element tree which we can also call the virtual DOM. This virtual DOM will be comitted to the actual DOM. ,_
> - _**How RSC works behind the scenes?** First the all Server Componets are rendered on the server as a rendering result a form of React Element. That React Element just contains the output of the Server Component. They only have information on how the DOM for each component will look like, they no longer contain the code itself that was necessart to render each component. The code from the Server Component has disappeared right on the server That the reason of not using hooks in Server Components. Because hooks has disappeared after the component is rendered. That react element has to be that way because it will be sent to the client and it should be serializable. Client Component doesn't be rendered on Server Side. Instead we can imagine this component tree contains a placeholder like a hole in the place where each client component will eventually be rendered. Each of these placeholders or holes contain the serialized props that might have been passed Server Component to current Client Component and the URL to the script that contains the actual component code. And this reference to the code is necessary so then the client component can be executed on the client. So the executed Service Component instances and unexecuted component instances is sent to client which is called RSC payload. This payload is essentially the virtual DOM of all Server Components these have already been rendered and some sub trees of un-rendered client components. This is called the RSC paylaod which that data structure will be sent to the client in the next step. On the Client side the sub-tree of client will be render and the virtual DOM has been completed. ,_
> - _We sent the Server Component as data not an html, because We don't want to be replaced with that new HTML and all current UI state would be lost every Server Component re-render. When the Server Component is re-rendered React is able to merge the current tree on the client with a nre tree coming from the server ,_
> - _As summary React Server Component, we start with a component tree that has both Server and Client Components ans is located on the server. In the RSC architecture the render process is split into two steps. First step where the Server Components are rendered and client components are not. They both exist in the same data structure that we call RSC payload. In RSC payload there is some information for each Client Componetns on the client side later. The RSC payload has a placeholder that includes serialized props passed from a parent Serever Component and the URL that points the script of Client Components code. At the second step with that data React will render the Client Component and render the virtual DOM ,_
> - _One step does not wait to other one to finish. Instead completed render work on the server is streamed to the client right away and integrated seamlessly into the tree on the client over time .,_
> - _SSR (Server Side Rendering) means take the React component tree render it as HTML to the browser. React Bundles which contains the React itself and the Component tree will also need to send browser so that HTML can be hydrated. Hydration is simply back the interactivity to the HTML. In the and we have interactive React App. Only difference is DOM has been genereated on the server not the client.,_
> - _Dynamic SSR is where HTML is generated for each incoming request. _
> - _Server Side Rendering and React Server Components aren't the same thing. They are separate technologies. RSC is not to replace SSR, but to complement it, to work together with it. ,_
> - _The server in Server Side Rendering and the server in React Server Component are not same thing. They can be the same thing but they don't have to be. React Server and React Client are simply two different environments. Two different parts of RSC protocol. React server doesn't even need to be an actual web server. A server is just a computer different from the browser. A computer the developer has access to and can run code on. RSC does not require a running web server. Instead server and client components coulds just be rendered once at build time in a process that we call static site generation. ,_
> - _SSR just take this component tree, render it as HTML and send that HTML to the browser. That the difference is both client and server components are rendered on the web server that Next.js provides. The Client and Server Side run on server on the initial render therefor the output is not DOM nÄ±tes but HTML which is sent to to the browser. Client Components also are rendered on the server on the first render because before React Server Components even existed all components were basically client components. They would all render on the server during server side rendering. Server Componetns will render all components on the server on the initial render. ,_
> - _After the entire component tree being rendered to HTML and shipped off to the browser. After the HTML has been sent, the react bundle needs to be sent. This will contain the React library itself and component's code so that component can be later rendered or hydrated on the client. This bundle will be split many different chunks which will be requested by the client as they become necessary over time. Rendering the Server Components produce the RSC payload which contains rendered server components and props and each Client Component's code URL. RSC Payload is different from the React bundle and it preserve state in the browser as Server Components get re-rendered later. RSC payload is also necessary wit React Bundle or chunks to hydrate the HTML so to make the HTML interactive again. The Client Components are only interactive so only Client Components get hydrated ,_
> - _SSR happents only initial render after that RSC works. On re-renders Client Components only render on the actual client. After the initial render React Server is the same as web server where Next.js is running. The React Client is the same as the user's browser. Whenever the Server Component gets rerendered a new RSC payload is generated an sent to the client, to the actual user's browser ready to be merged into the already existing React tree. The existing UI state can be preserved. ,_
> - _Both Client and Server Componenents are initially rendered on the server when SSR is used after then Server Components run on the actual web server and the client components run on the actual client, actual web browser. ,_
> - _**What is React Suspense?** Suspense is a built-in React Component to catch or to isolate components that are not ready to be rendered yet because they are doing some asynchronous work. And we say that these components or even entire sub trees are suspending because they are not yet ready to be rendered by React. We can say this component even entire sub trees are suspending because they are not ready to be rendered by React. It catches components that are suspending ,_
> - _What causes a component to be suspending? There are two asynchronous tasks. The first one is fetching data using a library that supports Suspense (React Query, Next.js) and second loading additional code using React's lazy loading feature ,_
> - _Suspense is native way to support and handle asynchronous operations in a declarative way. While rendering, suspneding component is found. It will move back up to the closest Suspense parent which we also call a Suspense boundary. It is a boundary because it separates the suspending sub tree from the rest of the app. When Suspense asynchronous works is done all the rendered components are discarded and the fallback component-Spinner- is displayed. We can render the Spinner instead of Product(has asynchronous works component) not the inside of product. Once the suspended component is ready and no longer suspending, React will attempt to render the sub tree under the Suspense boundary. ,_
> - _Components do not automatically suspend just because an asynchronous operation is happening inside them. Integrating async operations with Suspense is hard, ao we can use suspense with React Query, Next.js and Remix. Suspense works just as advertised when combined with React.lazy as we did earlier in the course. ,_
> - _A Fiber tree is an internal representation of each componetnt instance and DOM element of our app. Difference between Fiber tree and virtual DOM is fiber tree is a mutable data structure that is never destroyed. Which make it the perfect place to store state, hooks. And Fiber tree enables so-called concurrent features which allow React to pause rendering with Suspense in the first place. ,_
> - _Behind the scenes in the reconciliation phase whenever we use Suspense, the child tree below the suspense boundary is actually moved into another built-in component called activity. This happens in fiber tree so the activity component can not be seen in the Component tree. The fallback component that we also specify is also already placed in the fiber tree as the sibling of the activity. That fallback is hidden because so-called mode on activity is set to "visible". Meaning that the Suspense children are now visible then as soon as the componet Suspense this mode will be set to "hidden" and as a consequence the fallback spinner will be rendered and the sub tree will be hidden. Once the asynchronous work is done the activity mode gets set back to visible and the final sub-tree can finally be rendered. If a component suspends again later the fallback will be shown again and this entire process runs again as well, always keeping the sub-tree in the fiber tree. ,_
> - _The Suspense children are hidden and remain in the fiber tree means that all state in the sub tree is preserved during subsequent suspending and unsuspending phases ,_
> - _The fallback component will not be shown again if the function that trigged theSuspense wrapped in a transition (startTransition) function. In Next.js, all page navigations are wrapped inside transitions. If a component re-fetches data as a result of a page transition, the fallback component will not be shown again. We can fix this by passing a unique key prop. This will then reset this Suspense boundary ,_
> - _**How does Suspense actually know that a component is suspending?** The component that asynchronous works have done is child componen. So that child component throws a Promise which will trigger the Suspense boundary to render the fallback. ,_
>
> #
